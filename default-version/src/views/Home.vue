<template>
<div class="section">
  <div class="container grid-view">
    <p v-if="!queryFilteredItems" class="fallback">
      Loading..
    </p>
    <p v-else-if="queryFilteredItems && queryFilteredItems.length === 0" class="fallback">
      {{`No items were found matching “${this.searchQuery}”.`}}
    </p>
    <div
      v-else-if="queryFilteredItems && queryFilteredItems.length > 0"
      class="grid-container-fix"
    >
      <div
        v-for="item in queryFilteredItems"
        :key="item.id"
        class="grid-item"
      >
        <tawk-category-card :item="item" />
      </div>
    </div>
  </div>
</div>
</template>

<script>
import _ from 'lodash'
import axios from 'axios'
import CategoryCard from '../components/CategoryCard.vue'
import {eventBus, prodMode} from '../utils'

export default {
  components: {
    'tawk-category-card': CategoryCard
  },
  data: () => ({
    items: null,
    queryFilteredItems: null,
    searchQuery: ''
  }),
  watch: {
    searchQuery() {
      this.filterItemsBasedOnQuery()
    }
  },
  methods: {
    isEnabled: item => item.enabled,
    orderItems: items => items.sort((a, b) => a.order - b.order),
    filterItems(items) {
      return items.filter(item => this.isEnabled(item))
    },
    filterItemsBasedOnQuery() {
      this.queryFilteredItems = this.items.filter(item => _.includes(
        // converting strings below to lower case for the seek of a complete demo, nothing more..
        _.toLower(item.title),
        _.toLower(this.searchQuery)
      ))
    },
    async fetchCategories() {
      const suffix = prodMode ? '.json' : ''
      axios.get(`/api/categories${suffix}`)
        .then(response => {
          this.items = this.filterItems(response.data)
          this.items = this.orderItems(this.items)
          this.queryFilteredItems = this.items
        })
        .catch(error => ({error: JSON.stringify(error)}))
    },
    onQueryChanged(val) {
      this.searchQuery = val
    }
  },
  created() {
    this.fetchCategories()
    eventBus.$on('filter:items', this.onQueryChanged)
  },
  destroyed() {
    eventBus.$off('filter:items', this.onQueryChanged)
  }
}
</script>

<style lang="scss" scoped>
@import '../scss/_variables.scss';

.fallback {
  color: $text-gray;
}
</style>

<!-- global styles -->
<style lang="scss">
@import '../scss/_variables.scss';

p {
  font-family: $font-family;
  text-align: center;
  color: $text-black;
}

// my apologies for the inconvenience...
// the rule below should've been somewhere as shared styles.
// the reason to keep it here is to @extend it within grid view.
/* start of block */
.clearfix:before,
.clearfix:after {
  content: ' ';
  display: table;
}
.clearfix:after {
  clear: both;
}
/* end of block */

.section {
  background-color: $light-gray;
  .container {
    position: relative;
    max-width: $container--width;
    margin: 0 auto;
    padding: $container--padding-y 0;
  }
  .grid-view {
    @extend .clearfix;
    .grid-container-fix {
      @extend .clearfix;
      margin: 0 -($container-grid--gap*0.5);
      > .grid-item {
        float: left;
        width: (100%/3);
        padding: $container-grid--gap*0.5;
      }
    }
  }
  .grid-view, .container.grid-view {
    max-width: $container-grid--width;
  }
}
</style>